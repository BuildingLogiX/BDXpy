{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BDXpy Documentation","text":"<p> <code>bdxpy</code> is a Python package designed to interface with BuildingLogiX Data Exchange (BDX), a building analytics platform developed by BuildingLogiX.\ud83d\udcca</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Access BDX trends and analytics: Enables access to building information, trended data, equipment scores and energy analytics.</li> <li>Handles BDX authentication: Hides the complexity of BDX authentication and authorization mechanisms.</li> <li>Provides data in native format: Data series retrieved from BDX are available in Pandas DataFrame format, which enables intuitive processing in Python.</li> </ul> <p>Get started with installation instructions.</p>"},{"location":"#summary-overview-and-concepts","title":"Summary Overview and Concepts","text":"<p>This package allows users to interact with an API hosted on a BDX site. BDXpy is a Python library designed to facilitate interaction with BuildingLogiX's API for managing building data, trends, components, and hierarchies. This guide provides an overview of the library's features, including how to authenticate, retrieve data, and handle exceptions. It includes modules for authentication, session management, trend data retrieval, and component lookup. Our goals with BDXpy are:</p> <ul> <li>\ud83d\udd25 Allow a new canvas of opportunities for partners \u2013 almost endless with python and package features.</li> <li>\ud83d\ude80Quicker development ideas with examples from partners and internal BLX teams\ud83d\ude80</li> <li>More \u201cpower\u201d or experimentation on the end user.\u2714\ufe0f</li> <li>Take advantage of Open-Source capabilities and help \ud83d\udca1define what the future of FDD and Optimization could become at a lower cost.\ud83d\udca1</li> <li>\ud83d\udc4d Promote more advanced Machine Learning and Energy savings outcomes and grow the industry.</li> <li>\u2728\u2728Create a library/standard of advanced visualization and analysis available to the greater community.\u2728\u2728</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>https://buildinglogix.github.io/BDXpy/</li> <li>https://pypi.org/project/bdxpy/</li> <li>https://buildinglogix.net/</li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Automated custom reports</li> <li>Machine Learning Applications</li> <li>\ud83e\udd16 AI integrations (OpenAI, Gemini, etc.)</li> <li>Advanced/Custom Dashboards and Visualizations \ud83d\udcc9\ud83d\udcc9\ud83d\udcc9\ud83d\udcc9</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-bdxpy","title":"Contributing to BDXpy","text":"<p>We welcome and encourage participation in the BDXpy community! While direct code contributions are not required, here\u2019s how you can get involved:</p>"},{"location":"contributing/#share-your-creations","title":"\ud83d\udcca Share Your Creations","text":"<p>Showcase your charts, visualizations, and analyses in the GitHub Discussions section under User Creations. Upload images, share insights, and discuss results with the community.</p>"},{"location":"contributing/#ask-questions-troubleshoot","title":"\u2753 Ask Questions &amp; Troubleshoot","text":"<p>If you have questions about BDXpy, visit the Q&amp;A section in Discussions to get help. Check the Issues tab to see if your question has already been answered or report a bug.</p>"},{"location":"contributing/#reporting-issues","title":"\ud83d\udc1e Reporting Issues","text":"<p>Found a bug? Open a new issue in the Issues section with as much detail as possible. If applicable, include screenshots, error messages, or a minimal dataset to reproduce the issue.</p>"},{"location":"contributing/#suggest-features-improvements","title":"\ud83d\udca1 Suggest Features &amp; Improvements","text":"<p>Have an idea to improve BDXpy? Share it in Discussions</p> <p>\ud83d\ude80 Thank you for being a part of the BDXpy community! Your engagement helps improve the project for everyone. \ud83c\udf89</p>"},{"location":"examples/","title":"\ud83d\udcca Example Gallery","text":""},{"location":"examples/#basic-charting-and-data-visualization","title":"Basic Charting and Data Visualization","text":"<ul> <li> <p> AHU Static Comparison Show Code <pre><code># fake code for testing/display example, do not use\nfrom bdxpy import DataLoader\n\ndata = DataLoader.load(\"building_data.csv\")\nprint(data.summary())\n</code></pre> <p> </p> <li> <p> Campus Energy Map Show Code <pre><code>import pandas as pd\n\ndf = pd.read_csv(\"data.csv\")\nprint(df.head())\n</code></pre> <p> </p>"},{"location":"examples/#advanced-charts-and-data-visualization","title":"\ud83d\udd25 Advanced Charts and Data Visualization","text":""},{"location":"examples/#dashboards","title":"Dashboards","text":"<ul> <li> <p> RTU Dashboard Show Code <pre><code>import pandas as pd\nfrom bdx.core import BDX\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.types import TimeFrame, AggregationLevel\nfrom bdx.components import ComponentFilter\nimport plotly.express as px\nimport dash\nfrom dash import dcc, html, Output, Input, ctx\nfrom dash.dependencies import Input, Output\nimport re\n\n##### APP Contains commented our BDXpy api sections and loads csv with dummy data instead.\n\n# BDX Credentials and Connection\n# BDX_URL = \"http://yourBDXURL.com\"  # Replace with your actual BDX URL\n# USERNAME = \"BDX_USERNAME\"\n# PASSWORD = \"BDX_PASSWORD\"\n# BUILDING_NAME = \"BuildingLogiX Campus\"\n\n# # Authenticate\n# auth = UsernameAndPasswordAuthenticator(USERNAME, PASSWORD)\n\n# with BDX(BDX_URL, auth) as bdx:\n#     buildings = bdx.buildings.list()\n#     matching_buildings = [b for b in buildings if b.name.lower() == BUILDING_NAME.lower()]\n#     if not matching_buildings:\n#         print(f\"No building found with the name: {BUILDING_NAME}\")\n#         exit()\n\n#     BUILDING_ID = matching_buildings[0].componentInstanceId\n#     BUILDING_NODE = f\"Building: {BUILDING_NAME}\"\n\n#     print(f\"\\nSelected Building ID: {BUILDING_ID} for '{BUILDING_NAME}'\")\n\n#     components = bdx.components.by_building(BUILDING_ID)\n\n#     # Extract relevant component details into a DataFrame\n#     component_data = []\n\n#     # Iterate through retrieved components\n#     for component in components:\n#         component_data.append({\n#             \"Component ID\": component.componentInstanceId,\n#             \"Display Name\": component.path.displayName if component.path else \"N/A\",\n#             \"Full Path\": component.path.fullPath if component.path else \"N/A\",\n#             \"Template Type\": component.templateType,\n#             \"Parent Name\": component.parentName,\n#             \"Root Parent Name\": component.rootParentName\n#         })\n\n#     # Convert to DataFrame\n#     components_df = pd.DataFrame(component_data)\n\n\n#     filtered_components = [\n#         c for c in components\n#         if c.templateType == \"LargeRtu\" and c.path and \"RTU_\" in c.path.displayName\n#     ]\n\n#     # Convert filtered components to a DataFrame\n#     filtered_data = [\n#         {\n#             \"Component Inst ID\": c.componentInstanceId,\n#             \"Display Name\": c.path.displayName,\n#             \"Full Path\": c.path.fullPath,\n#             \"Template Type\": c.templateType,\n#         }\n#         for c in filtered_components\n#     ]\n\n#     filtered_df = pd.DataFrame(filtered_data)\n\n#     print(filtered_df)\n\n#     # Define properties to retrieve\n#     properties_to_fetch = [\n#         \"ductStaticPressure\",\n#         \"ductStaticPressureSetpoint\",\n#         \"supplyAirTemp\",\n#         \"supplyFanVFDPercent\",\n#         \"supplyFanVFDPower\",\n#         \"coolOutput\",\n#         \"supplyFanStatus\"\n#     ]\n\n#     data_requests = []\n\n#     # Create property descriptors\n#     for component in filtered_components:\n#         if component.path and component.path.componentPathId:  # Ensure the path exists\n#             for prop in properties_to_fetch:\n#                 data_requests.append({\n#                     \"componentPathId\": component.path.componentPathId,\n#                     \"propertyName\": prop\n#                 })\n\n#     # Debugging: Check if requests were created\n#     print(f\"Total Data Requests: {len(data_requests)}\")\n#     if len(data_requests) == 0:\n#         print(\"\u26a0 No data requests were generated! Check component paths.\")\n\n#     # Fetch trending data for the last 7 days\n#     timeframe = TimeFrame.last_7_days()\n#     retrieval_result = bdx.trending.retrieve_data(data_requests, timeframe, AggregationLevel.POINT)\n\n#     # Convert the data to a Pandas DataFrame\n#     df = retrieval_result.dataframe\n\n#     # Create a mapping for renaming columns\n#     column_renaming = {}\n\n#     # Iterate through the filtered components to find correct display names\n#     for component in filtered_components:\n#         if component.path and component.path.componentPathId:  # Ensure valid path\n#             for prop in properties_to_fetch:\n#                 old_column_name = f\"{component.path.componentPathId}_{prop}\"\n#                 new_column_name = f\"{component.path.displayName}_{prop}\"\n#                 column_renaming[old_column_name] = new_column_name\n\n#     # Rename the columns\n#     df.rename(columns=column_renaming, inplace=True)\n\n#     # Print sample data with updated column names\n#     print(df.head())\n\n# -------------------------------------------------------------------------\n# 1) Load CSV data for dummy app data\n# -------------------------------------------------------------------------\ncsv_file = \"bdx_large_rtu_data_ex.csv\"  # Update if needed\ndf = pd.read_csv(csv_file)\ndf['time'] = pd.to_datetime(df['time'])  # Ensure 'time' is a datetime\n\n# -------------------------------------------------------------------------\n# 2) Extract RTU names using regex\n# -------------------------------------------------------------------------\nrtu_names = sorted(\n    set(re.findall(r'RTU_\\d+', col)[0] for col in df.columns if re.findall(r'RTU_\\d+', col))\n)\n\n# -------------------------------------------------------------------------\n# 3) Define a color map for RTUs\n# -------------------------------------------------------------------------\ncolor_seq = px.colors.qualitative.Dark24  # or choose another\ncolor_map = {}\nfor i, rtu in enumerate(rtu_names):\n    color_map[rtu] = color_seq[i % len(color_seq)]\n\n# For wide-format line plots, define a color sequence matching rtu_names order\nwide_format_colors = [color_map[rtu] for rtu in rtu_names]\n\n# -------------------------------------------------------------------------\n# 4) Define GPS coordinates for the 17 RTUs (example data)\n# -------------------------------------------------------------------------\nrtu_gps_data = {\n    \"RTU#\": [f\"RTU_{i}\" for i in range(1, 18)],\n    \"Latitude\": [\n        52.00837569274067, 52.00830627568983, 52.00875609626744, 52.00854506989283,\n        52.009003217993765, 52.00886993902999, 52.009108730225236, 52.009291987720204,\n        52.0095002339626, 52.009336413666574, 52.009850085476714, 52.0101804982761,\n        52.0103470920397, 52.00682072496339, 52.006956786798256, 52.006543046465836,\n        52.0071900346995\n    ],\n    \"Longitude\": [\n        -0.6927407350645639, -0.6933361764343267, -0.6924385034602146, -0.6916310488754607,\n        -0.6915904506002495, -0.6919964333523606, -0.6904852753306141, -0.690088314417439,\n        -0.6904762534916784, -0.6932865563201799, -0.6924610580520515, -0.6922445339175922,\n        -0.6918746385212245, -0.6932053597447845, -0.6927768223953339, -0.6926550275697007,\n        -0.6916265378920792\n    ]\n}\nrtu_gps_df = pd.DataFrame(rtu_gps_data)\n\n# Calculate average lat/lon for map centering\ncenter_lat = rtu_gps_df[\"Latitude\"].mean()\ncenter_lon = rtu_gps_df[\"Longitude\"].mean()\n\n# -------------------------------------------------------------------------\n# 5) Dash App layout\n# -------------------------------------------------------------------------\napp = dash.Dash(__name__)\napp.layout = html.Div([\n    html.Div([\n        html.Img(src=\"/assets/blx white.svg\", className=\"logo\"),  # Logo (Make sure it's in the \"assets\" folder)\n        html.H1(\"BuildingLogiX RTU Monitoring\", className=\"header-text\")\n    ], className=\"header\", style={\"backgroundColor\": \"#00274D\", \"padding\": \"15px\", \"textAlign\": \"center\"}),\n    html.Div([\n        # Left column\n        html.Div([\n            # Top row: Map\n            dcc.Graph(id='map-runtime', style={'height': '700px'}, config={'scrollZoom': True}),\n\n            # Middle row: Violin (SupplyAirTemp, fan on)\n            dcc.Graph(id='violin-supply-air'),\n\n            # Bottom row: Time series (SupplyAirTemp)\n            dcc.Graph(id='time-series-supply-air')\n        ], style={'width': '50%', 'display': 'inline-block'}),\n\n        # Right column\n        html.Div([\n            # Top row: Polar (VFD Power)\n            dcc.Graph(id='polar-vfd-power', style={'height': '700px'}),\n\n            # Middle row: Violin (Duct Static, fan on)\n            dcc.Graph(id='kde-duct-static'),\n\n            # Bottom row: Time series (SupplyFanSpeed)\n            dcc.Graph(id='time-series-duct-static')\n        ], style={'width': '50%', 'display': 'inline-block'})\n    ])\n])\n\n# -------------------------------------------------------------------------\n# 6) Dash Callback for all figures\n# -------------------------------------------------------------------------\n@app.callback(\n    Output('map-runtime', 'figure'),\n    Output('violin-supply-air', 'figure'),\n    Output('time-series-supply-air', 'figure'),\n    Output('polar-vfd-power', 'figure'),\n    Output('kde-duct-static', 'figure'),\n    Output('time-series-duct-static', 'figure'),\n    Input('map-runtime', 'clickData'),\n)\n\ndef update_charts(_):\n    \"\"\"\n    Returns six figures for the dashboard:\n    1) Map showing RTU runtime hours (marker size), labeled with RTU name + hours\n    2) Violin plot of Supply Air Temp (fan on)\n    3) Time series of Supply Air Temp (wide format)\n    4) Polar chart of VFD Power (most recent sample)\n    5) Violin plot of Duct Static Pressure (fan on)\n    6) Time series of Supply Fan Speed (wide format)\n    \"\"\"\n\n    # ---------------------------------------------------------------------\n    # A) Most recent data row (for polar chart)\n    # ---------------------------------------------------------------------\n    latest_data = df.iloc[-1]\n\n    # ---------------------------------------------------------------------\n    # B) Map: RTU Runtime Hours\n    # ---------------------------------------------------------------------\n    # Summation of supplyFanStatus over all rows =&gt; total \"on\" intervals\n    # Each row is presumably 15 minutes =&gt; multiply by 0.25 to convert to hours\n    runtime_values = [\n        df[f\"{rtu}_supplyFanStatus\"].sum() * 0.25\n        for rtu in rtu_names\n    ]\n\n    # Build a DF for the map\n    runtime_df = rtu_gps_df.copy()\n    runtime_df[\"RuntimeHours\"] = runtime_values\n\n    # Add a label with RTU name and hours on separate lines\n    runtime_df[\"Label\"] = runtime_df[\"RTU#\"] + \"&lt;br&gt;\" + runtime_df[\"RuntimeHours\"].round(1).astype(str) + \" hrs\"\n\n\n    map_fig = px.scatter_mapbox(\n        runtime_df,\n        lat=\"Latitude\",\n        lon=\"Longitude\",\n        size=\"RuntimeHours\",\n        size_max=20,\n        color=\"RuntimeHours\",  # Assigns a color gradient based on runtime\n        color_continuous_scale=\"Viridis\",  # You can use \"Plasma\", \"Cividis\", \"Turbo\", etc.\n        hover_name=\"RTU#\",      # Shown in hover tooltip\n        text=\"Label\",           # Shown on the map\n        title=\"RTU Runtime Map - Last 7 Days\",\n        zoom=15.5,\n        center=dict(lat=center_lat, lon=center_lon),\n        mapbox_style=\"carto-positron\"\n    )\n\n    # Display the labels above each marker\n    map_fig.update_traces(\n        mode=\"markers+text\",\n        textposition=\"bottom center\"\n    )\n\n    map_fig.update_layout(\n        dragmode=\"pan\",\n        uirevision=\"constant\",\n        mapbox=dict(\n            pitch=60,  # Tilt for 3D effect\n            bearing=0,  # Rotate the view\n            style=\"carto-positron\"\n        )\n    )\n\n\n\n    # ---------------------------------------------------------------------\n    # C) Violin: SupplyAirTemp (fan on)\n    # ---------------------------------------------------------------------\n    sat_dfs = []\n    for rtu in rtu_names:\n        sub_df = df[['time', f\"{rtu}_supplyAirTemp\", f\"{rtu}_supplyFanStatus\"]].copy()\n        sub_df.rename(columns={\n            f\"{rtu}_supplyAirTemp\": \"SupplyAirTemp\",\n            f\"{rtu}_supplyFanStatus\": \"SupplyFanStatus\"\n        }, inplace=True)\n        sub_df[\"RTU\"] = rtu\n        sat_dfs.append(sub_df)\n\n    melted_sat = pd.concat(sat_dfs, ignore_index=True)\n\n    # Filter to fan on (True or ==1, depending on your data)\n    melted_sat = melted_sat[melted_sat[\"SupplyFanStatus\"] == True]\n    melted_sat.dropna(subset=[\"SupplyAirTemp\"], inplace=True)\n\n    # Sort RTUs by descending average supply air temp\n    avg_sat = melted_sat.groupby(\"RTU\")[\"SupplyAirTemp\"].mean().sort_values(ascending=False)\n    rtu_order_sat = list(avg_sat.index)\n\n    violin_sat_fig = px.violin(\n        melted_sat,\n        x=\"RTU\",\n        y=\"SupplyAirTemp\",\n        color=\"RTU\",\n        color_discrete_map=color_map,\n        category_orders={\"RTU\": rtu_order_sat},\n        box=True,\n        points=False,\n        hover_data=[\"time\"],\n        title=\"Operating Supply Air Temp\"\n    )\n\n    # ---------------------------------------------------------------------\n    # D) Time Series: SupplyAirTemp (wide format)\n    # ---------------------------------------------------------------------\n    supply_temp_fig = px.line(\n        df,\n        x=\"time\",\n        y=[f\"{rtu}_supplyAirTemp\" for rtu in rtu_names],\n        title=\"Supply Air Temp Over Time\",\n        color_discrete_sequence=wide_format_colors\n    )\n\n    # ---------------------------------------------------------------------\n    # E) Polar Chart: Supply Fan VFD Power (most recent)\n    # ---------------------------------------------------------------------\n    polar_df = pd.DataFrame({\n        \"RTU\": rtu_names,\n        \"VFDPower\": [latest_data[f\"{rtu}_supplyFanVFDPower\"] for rtu in rtu_names]\n    })\n\n    polar_fig = px.bar_polar(\n        polar_df,\n        r=\"VFDPower\",\n        theta=\"RTU\",\n        color=\"RTU\",\n        color_discrete_map=color_map,\n        title=\"RTU kW (Most Recent)\"\n    )\n\n    # ---------------------------------------------------------------------\n    # F) Violin: Duct Static Pressure (fan on)\n    # ---------------------------------------------------------------------\n    rtu_dfs_2 = []\n    for rtu in rtu_names:\n        sub_df = df[['time', f\"{rtu}_ductStaticPressure\", f\"{rtu}_supplyFanStatus\"]].copy()\n        sub_df.rename(columns={\n            f\"{rtu}_ductStaticPressure\": \"DuctStaticPressure\",\n            f\"{rtu}_supplyFanStatus\": \"SupplyFanStatus\"\n        }, inplace=True)\n        sub_df[\"RTU\"] = rtu\n        rtu_dfs_2.append(sub_df)\n\n    melted_static = pd.concat(rtu_dfs_2, ignore_index=True)\n\n    # Filter to fan on (True or 1)\n    melted_static = melted_static[melted_static[\"SupplyFanStatus\"] == True]\n    melted_static.dropna(subset=[\"DuctStaticPressure\"], inplace=True)\n\n    avg_static = melted_static.groupby(\"RTU\")[\"DuctStaticPressure\"].mean().sort_values(ascending=False)\n    rtu_order = list(avg_static.index)\n\n    kde_fig = px.violin(\n        melted_static,\n        x=\"RTU\",\n        y=\"DuctStaticPressure\",\n        color=\"RTU\",\n        color_discrete_map=color_map,\n        category_orders={\"RTU\": rtu_order},\n        box=True,\n        points=False,\n        hover_data=[\"time\"],\n        title=\"Operating Duct Static Pressure\"\n    )\n\n    # ---------------------------------------------------------------------\n    # G) Time Series: Supply Fan Speed (wide format)\n    # ---------------------------------------------------------------------\n    speed_fig = px.line(\n        df,\n        x=\"time\",\n        y=[f\"{rtu}_supplyFanVFDPercent\" for rtu in rtu_names],\n        title=\"Supply Fan Speed Over Time\",\n        color_discrete_sequence=wide_format_colors\n    )\n\n    return (\n        map_fig,\n        violin_sat_fig,\n        supply_temp_fig,\n        polar_fig,\n        kde_fig,\n        speed_fig\n    )\n\n\n\nif __name__ == '__main__':\n    app.run_server(debug=False)\n</code></pre> <p> </p>"},{"location":"examples/#automated-reporting","title":"\ud83d\udd25 Automated Reporting","text":"<p>More examples coming soon!</p>"},{"location":"examples/#calculations-and-analysis","title":"Calculations and Analysis","text":"<p>More examples coming soon!</p>"},{"location":"examples/#basic-machine-learning","title":"Basic Machine Learning","text":"<p>More examples coming soon!</p>"},{"location":"examples/#basic-llm-integration","title":"Basic LLM Integration","text":"<p>More examples coming soon!</p>"},{"location":"examples/#public-kiosk-app","title":"Public Kiosk App","text":"<p>More examples coming soon!</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-do-i-install-bdxpy","title":"How do I install BDXpy?","text":"<p>Use pip: <pre><code>pip install bdxpy\n</code></pre> See the installation section.</p>"},{"location":"faq/#how-do-use-bdxpy","title":"How do use BDXpy?","text":"<p>See our workflow diagram for getting started: workflow bdxpy.</p>"},{"location":"faq/#do-i-have-to-pay-for-bdxpy","title":"Do I have to pay for BDXpy?","text":"<p>BDXpy requires an active BDX license including the license feature for RemoteAPI. Installation of the Python package BDXpy is free and publicly available as well as all documentation and some basic examples to get users started.</p>"},{"location":"faq/#what-if-i-dont-know-python","title":"What if I don't know Python?","text":"<p>Python is one of the most widely used programming languages and is open-source. It has many resources, classes, examples online beginners can pull from. Likewise most AI chatbots like ChatGPT, Gemini, etc. all generally quite good a Python development and we highly encourage beginners to utilize all these available tools.  </p> <p>BuildingLogiX is also working on forming a dedicated BDXpy custom GPT, coming soon.....</p>"},{"location":"faq/#what-are-ides-which-one-should-i-use-for-bdxpy","title":"What are IDEs, which one should I use for BDXpy?","text":"<p>An IDE (Integrated Development Environment) is a software application that provides coding tools, such as syntax highlighting, debugging, and auto-completion, to make development easier.</p> <p>For working with BDXpy, most of our team uses VS Code most of the time or Jupyter Notebook in VS Code. There are others we also recommend depending on your experience and preference:</p> <ul> <li>VS Code \u2013 Lightweight, customizable, and great for Python development.</li> <li>PyCharm \u2013 More feature-rich, with advanced debugging and code analysis.</li> <li>Jupyter Notebook \u2013 Best for interactive data analysis and quick visualizations.</li> <li>Spyder \u2013 Designed for data science, similar to MATLAB.  </li> </ul> <p>\ud83d\udc49 Recommendation: If you need a full-fledged Python IDE, VS Code or PyCharm is great. If you are doing data exploration, try Jupyter Notebook.</p>"},{"location":"faq/#what-is-the-difference-between-python-and-jupyter-notebook-files","title":"What is the difference between Python and Jupyter Notebook files?","text":"<ul> <li>Python scripts (.py):<ul> <li>Standard Python files used for writing and executing programs. Run using a terminal, command line, or an IDE like VS Code/PyCharm. Best for larger projects and production-ready code.</li> </ul> </li> <li>Jupyter Notebooks (.ipynb):<ul> <li>An interactive environment that allows you to mix code, markdown, and visualizations. Best for data analysis, quick prototyping, and educational purposes. Supports inline plots (like matplotlib and seaborn).  </li> </ul> </li> </ul> <p>\ud83d\udc49 Recommendation: Use .py for software development and .ipynb for analysis, documentation, or interactive work.</p>"},{"location":"faq/#can-buildinglogix-help-me-develop-in-python","title":"Can BuildingLogiX help me develop in Python?","text":"<p>Yes, BuildingLogiX has in-house developers and engineers who are happy to assist. IF you want to collarborate on BDXpy development it is considered custom development and involves working directly with our team! We will also likely have a series of small training seminars annual on BDXpy. Reach out to us if you are interested.</p>"},{"location":"faq/#who-can-i-contact-for-support","title":"Who can I contact for support?","text":"<p>Email us at technical.support@buildinglogix.net.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#architecture-options","title":"Architecture Options","text":"<p>There are a couple different ways to run/deploy BDXpy depending on your needs and use cases. Technically multiple sources of BDXpy could be running simultaneously performing various tasks. Disclaimer: BDXpy is intended for power users and rates of data collection should be reasonable and if too many requests of large quantities of data  are simultaneously taking place it could strain the BDX application and database servers as well as the local machine hosting BDXpy as large data frames can become memory intensive. BDXpy limitations are dependent both on the location of its operation but also the BDX instance it communicates with. It\u2019s the responsibility of the user to make smart decisions with this knowledge. BDXpy (as the below image suggests) can be used on an existing BDX server, on a dedicated server, or run from a laptop/computer. In all cases the network path between the BDX instance and BDXpy needs to be active for scripts and processes using BDXpy to work.</p>"},{"location":"getting-started/#deployment-cases","title":"Deployment Cases","text":"<ol> <li>On a laptop/personal computer: for engineers wanting to experiment, run reports from their machine, non-24/7 script deployments.<ul> <li>Easiest way to get started or pilot something before deploying elsewhere so long as user has access to BDX from laptop</li> </ul> </li> <li>On an existing BDX server: likely for an on-premises installation where data is served back to BDX via Windows IIS and are publishing BDXpy internally with identical firewall rules to BDX.<ul> <li>Install here if you want BDXpy files to feedback to the kiosk or custom apps/widgets. Maybe require IT approval or cooperation</li> </ul> </li> <li>On a dedicated BDXpy server: user who might have a cloud BDX but locally want to serve up private network, but internal (non-authenticated) dashboard/visuals/kiosks on a local network. Or users who have more powerful tasks or server resources or teams that shouldn\u2019t/can\u2019t access the BDX server RDP directly or who want to have scripts automatically run on a timed/automated schedule<ul> <li>Dedicated servers could also be cloud VMs if they have access to BDX where automated reports or new apps are created. Doesn\u2019t require extra IT permissions or resources on the BDX server depending on the scope.</li> </ul> </li> <li>Cloud Functions: BDXpy scripts can be run in serverless environments such as AWS Lambda or Azure Functions provided, they don\u2019t entail long running or complex processes or other serverless constraints and have access to communicate with the BDX instance/server. See cloud provider for details</li> </ol>"},{"location":"getting-started/#process-overview-from-bdx-to-bdxpy-and-python-outputs","title":"Process Overview \u2013 From BDX to BDXpy and Python Outputs","text":""},{"location":"getting-started/#checking-the-bdx-license-for-bdxpy","title":"Checking the BDX license for BDXpy","text":"<p>BDXpy requires a license feature on the source BDX. These can be viewed in a BDX instance under Manage Licenses to ensure the feature is enabled as in the image below.\u2705</p> <p></p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Installing the BDX Python package is relatively simple. The first thing required is to download the Python language onto your device.</p> <ol> <li>BDXpy requires Python 3.12 or newer versions (newer versions are recommended). This can be done through the Python downloads website.</li> <li>Ensure BDX instance is licensed for API access.</li> <li>After installing the necessary packages and obtaining the correct licensing, install BDXpy just like any other Python package:</li> </ol> <p><pre><code>pip install bdxpy\n</code></pre> Information on pip here.</p>"},{"location":"getting-started/#requirements-packaged-that-come-with-bdxpy","title":"Requirements packaged that come with BDXpy","text":"<p>BDXpy requires Python 3.12+ and the following dependencies which will be installed with BDXpy:</p> <ul> <li>requests</li> <li>pandas</li> <li>nacl</li> <li>urllib3</li> <li>dacite</li> </ul> <p>Note: you do not need to install these separately as they come with BDXpy, this is purely for reference.</p>"},{"location":"getting-started/#bdxpy-imports","title":"BDXpy Imports","text":"<p>To make use of bdxpy functions python will need \u201cimports\u201d from the package. These imports reside before the code/functions are called in the python script and are all typically handled in the beginning lines of the code like below:</p> <pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame\nfrom bdx.components import Components\n\n## examples of other python package imports (but not limited to) that can be used with data from BDXpy\nfrom datetime import datetime, timedelta\nimport os\nfrom dotenv import load_dotenv\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"getting-started/#bdxpy-license","title":"BDXpy License","text":"<p>This package is distributed under a proprietary license. Contact BuildingLogiX for licensing information.</p> <p>Learn more about BuildingLogiX Data Exchange (BDX) here. BDXpy on [pypi].(https://pypi.org/project/bdxpy/)</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#authentication-and-session-setup","title":"Authentication and Session Setup","text":""},{"location":"reference/#using-a-env-file-for-credentials","title":"Using a .env File for Credentials","text":"<p>To enhance security, you can store the username and password in a .env file rather than hardcoding them into your python code.  Note: Files containing the credentials should have appropriate security practices in place such as user/server permissions so they cannot be accessed/stolen/or compromised.  Below are the examples to set up and use a .env file for authentication. More on this process and security can also be found online.</p> <ol> <li>Create a .env File In your project directory, create a file named .env with the following content: <pre><code>BDX_USERNAME=your_username\nBDX_PASSWORD=your_password\n</code></pre></li> <li>Install the python-dotenv Library Install the library to load environment variables from the .env file: <pre><code>pip install python-dotenv\n</code></pre></li> <li>Load Environment Variables in Your Script Use the following code to load the .env file and authenticate with BDX:</li> </ol> <pre><code>from dotenv import load_dotenv\nimport os\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\n\n# Specify the path to the environment variable file\nload_dotenv(dotenv_path=r\"C:\\Users\\your-path\\.env\")\n\nusername = os.getenv(\"BDX_USERNAME\")\npassword = os.getenv(\"BDX_PASSWORD\")\n\nif not username or not password:\n    raise EnvironmentError(\"Environment variables BDX_USERNAME and BDX_PASSWORD must be set in the .env file\")\n\nauthenticator = UsernameAndPasswordAuthenticator(username, password)\nwith BDX(\"http://yourBDXURL.com\", authenticator) as bdx_instance:\n\n    print(\"Connection successful!\") \n</code></pre>"},{"location":"reference/#credentials-in-script","title":"Credentials in script","text":"<p>For testing purposes the BDX_USERNAME and BDX_PASSWORD can also be copied into the authentication in python.</p> <pre><code>with BDX(\"http://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\n  \"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n</code></pre>"},{"location":"reference/#important-notes-on-authentication","title":"Important Notes on Authentication","text":"<ul> <li>Currently, the authentication method requires the user to be a BDX local user or an LDAP user. Users authenticated via Single Sign-On (SSO) or Multi-Factor Authentication (MFA) are not supported or applicable by BDXpy.</li> <li>Ensure you have a local BDX username and password for successful authentication that is dedicated to BDXpy. Do not use regular usernames or admin credentials for reoccurring scripts.</li> <li>The credentials used for BDXpy must have BDX security permissions to access the data you are requesting as well as the BDX permissions listed below:<ul> <li>BDXUser</li> <li>TrendViewDataAccess</li> </ul> </li> </ul> <ul> <li>And any device/building/system read permissions necessary found under Manage Path Access if Object Level Security is enabled in BDX.</li> <li>BDXpy is generally intended for use by advanced power users and admin users  even with basic permissions in the BDX app its important to secure your credentials and appoint a BDXpy lead to ensure all uses of the product are being authorized and managed properly.</li> <li>From an authentication perspective BDXpy should be limited in the users BDXpy calls from for audit log and tracking practices. (aka a limited number of users of a single BDX instance and not for mass use by basic security users).</li> </ul>"},{"location":"reference/#component-retrieval-structure","title":"Component Retrieval Structure","text":"<p>BDXpy uses <code>componentPathId</code> to call devices and properties. This applies to buildings and all child devices in BDX. <code>componentPathId</code> is the unique identifier path from the source data agent or parent BDX properties in the hierarchy of devices.</p> <p>Note: <code>componentPathId != componentInstanceID</code></p>"},{"location":"reference/#component-structure-analogy","title":"Component Structure Analogy","text":"<ul> <li>Component path: \"File path\" of a component.</li> <li>Component path ID: \"File inode number.\"</li> <li>This is what BDXpy will use in component retrieval.</li> <li>Component instance ID: File version.</li> </ul>"},{"location":"reference/#defining-devices-for-data-retrieval","title":"Defining Devices for Data Retrieval","text":"<p>Before retrieving data, a user needs to define a set of devices to pull properties from, which will require outlining the <code>componentPathId</code>s of these devices.</p>"},{"location":"reference/#methods-to-lookup-componentpathid","title":"Methods to Lookup <code>componentPathId</code>","text":"<ol> <li>Use methods in BDXpy to lookup or call <code>componentPathId</code>.</li> <li>Manually find the <code>componentPathId</code> under Manage Device Information in BDX.</li> <li>Lookup information in the Custom Query Tool in BDX.</li> </ol>"},{"location":"reference/#overview-of-methods-to-get-componentpathid","title":"Overview of Methods to Get <code>componentPathId</code>","text":"<p>In its simplest form, a <code>componentPathId</code> can be found if you know the <code>componentInstanceId</code>.</p>"},{"location":"reference/#example-retrieve-a-component-by-instance-id","title":"Example: Retrieve a Component by Instance ID","text":"<pre><code>from dotenv import load_dotenv\nimport os\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\n\n# Specify the path to the environment variable file\nload_dotenv(dotenv_path=r\"C:\\Users\\your-path\\.env\")\n\nusername = os.getenv(\"BDX_USERNAME\")\npassword = os.getenv(\"BDX_PASSWORD\")\n\nif not username or not password:\n    raise EnvironmentError(\"Environment variables BDX_USERNAME and BDX_PASSWORD must be set in the .env file\")\n\nauthenticator = UsernameAndPasswordAuthenticator(username, password)\nwith BDX(\"http://yourBDXURL.com\", authenticator) as bdx_instance:\n\n    print(\"Authenticated successfully!\")\n\n    # Retrieve component by ID\n    component_instance_id = 8590005002\n\n    component = bdx_instance.components.by_id(component_instance_id)\n\n    # Extract component details\n    component_name = component.path.displayName\n    full_path = component.path.displayFullPath\n    component_path_id = component.path.componentPathId\n\n    print(f\"Component Name: {component_name}\")\n    print(f\"Component Inst ID: {component_instance_id}\")\n    print(f\"Component Full Path: {full_path}\")\n    print(f\"Component Path ID: {component_path_id}\")\n</code></pre> <p>Output: <pre><code>Authenticated successfully!\nComponent Name: BuildingLogiX Campus\nComponent Inst ID: 4294967534\nComponent Full Path: /Buildings/BuildingLogiX Campus\nComponent Path ID: 4294967534\n</code></pre></p> <p>If you know a building ID you can then print out all its components and their IDs:</p> <p><pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame, AggregationLevel\nimport pandas as pd\nfrom dotenv import load_dotenv\nimport os\n\ndef get_component_table(bdx_instance, building_id):\n    try:\n        # Retrieve components by building ID\n        components = bdx_instance.components.by_building(building_id)\n\n        # Create a list to hold the component details\n        component_data = []\n\n        # Loop through the components and collect the details\n        for component in components:\n            # Extract component details\n            component_name = component.path.displayName\n            full_path = component.path.displayFullPath\n            component_path_id = component.path.componentPathId\n            component_instance_id = component.componentInstanceId  # Add component instance ID\n            entity_type = component.entityTypeName  # Component type\n            template_type = component.templateType  # Template type\n\n            # Append to the component_data list\n            component_data.append({\n                'Component Name': component_name,\n                'Full Path': full_path,\n                'Component Path ID': component_path_id,\n                'Component Instance ID': component_instance_id,  # New column\n                'Entity Type': entity_type,  # Add component type\n                'Template Type': template_type  # Add template type\n            })\n\n        # Convert the list into a Pandas DataFrame\n        df = pd.DataFrame(component_data)\n\n        # Write DataFrame to CSV\n        file_path = r'C:yourPath\\BDXpy\\component_data.csv'\n        df.to_csv(file_path, index=False)\n\n        return df  # Return the DataFrame\n\n    except Exception as e:\n        print(f\"Error retrieving components: {str(e)}\")\n        return None\n\n# Use this function in the run method like this:\ndef run():\n    with BDX(\"https://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n\n        # Retrieve components by building ID\n        building_id = 4294967302  # Replace with your actual Building ID\n\n        # Get the table of components\n        component_table = get_component_table(bdx_instance, building_id)\n\n        # Display the table\n        if component_table is not None:\n            print(component_table)\n\nif __name__ == \"__main__\":\n    run()\n</code></pre> CSV output: </p>"},{"location":"reference/#example-building-id-retrieval","title":"Example: Building ID Retrieval","text":"<p>To retrieve building data, use the buildings module. The list() method retrieves summaries of all accessible buildings.</p> <p><pre><code>from dotenv import load_dotenv\nimport os\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nimport pandas as pd\n\n# Specify the path to the environment variable file\nload_dotenv(dotenv_path=r\"C:\\Users\\your-path\\.env\")\n\nusername = os.getenv(\"BDX_USERNAME\")\npassword = os.getenv(\"BDX_PASSWORD\")\n\nif not username or not password:\n    raise EnvironmentError(\"Environment variables BDX_USERNAME and BDX_PASSWORD must be set in the .env file\")\n\nauthenticator = UsernameAndPasswordAuthenticator(username, password)\nwith BDX(\"http://yourBDXURL.com\", authenticator) as bdx_instance:\n\n    print(\"Authenticated successfully!\")\n\n###### Retrieve building summaries for all buildings in your BDX site ######\nbuilding_summaries = bdx_instance.buildings.list()\n\n# Convert building summaries to a DataFrame\ndata = [\n    {\n        \"Building Name\": building.name,\n        \"Building ID\": building.componentInstanceId,\n        \"Square Footage\": building.sqft,\n        \"Address\": f\"{building.address.addr1}, {building.address.city}, {building.address.state}\"\n\n    }\n    for building in building_summaries\n]\nbuilding_df = pd.DataFrame(data)\n\n# Display the first few rows of the DataFrame\nprint(building_df)\n</code></pre> Output: </p>"},{"location":"reference/#manage-device-information-in-bdx","title":"Manage Device Information in BDX","text":"<p>Within BDX, users can navigate to Manage Device Information in the upper left navigation. There user can navigate the BDX buildings, hierarchy, and device to look information. This includes the ability to get <code>componentInstanceId</code> which can then be translated with BDXpy to <code>componentPathId</code> per the code below.</p> <p></p> <pre><code># Retrieve component by ID\ncompInstID = 4294967535\ncomponent = bdx.components.by_id(compInstID)\n# Extract component details\ncomponent_name = component.path.displayName\nfull_path = component.path.displayFullPath\ncomponent_path_id = component.path.componentPathId\n\nprint(f\"Component Name: {component_name}\")\nprint(f\"Component Inst ID: {compInstID}\")\nprint(f\"Component Full Path: {full_path}\")\nprint(f\"Component Path ID: {component_path_id}\")\n</code></pre>"},{"location":"reference/#custom-query-tool-lookup-in-bdx","title":"Custom Query Tool lookup in BDX","text":"<p>Navigate to the Custom Query Tool in your BDX instance. In the Advanced Query Mode the various query text below can be pasted and run to retrieve <code>componentPathId</code>.</p>"},{"location":"reference/#building-lookup","title":"Building lookup","text":"<p>This is an example advanced query that can be run from BDX to return values.</p> <p>`select b.name, b.componentInstanceId, b.path.componentPathId  from Building b```</p> <p></p>"},{"location":"reference/#raw-assigned-point-id-lookups","title":"\"Raw\" assigned point ID lookups","text":"<p>The query below looks up any assigned folder or raw points listed under the building (see Manage Buildings &gt; Assigned Point Folders List in BDX). Users can specify/filter the building name in the BDX query below.</p> <p><code>select pf.folderPathAlias,  pf.folderPath.fullPath, pf.folderPath.componentPathId, pf.folderPath.currentComponent.componentInstanceId from Building b  join b.assignedPointFolders pf  where b.name = 'BuildingLogiX Campus'</code></p> <p></p>"},{"location":"reference/#built-in-component-filtering","title":"Built-in Component Filtering","text":"<p><code>ComponentFilter</code> is a filtering mechanism used in BDXpy to refine searches when retrieving building components. It allows filtering by specific attributes like template type, path keyword, and subscription status.</p> <pre><code>from bdx.core import BDX\nfrom bdx.components import ComponentFilter\n</code></pre>"},{"location":"reference/#attributes","title":"Attributes","text":"<ul> <li><code>template_type</code> (str, optional) \u2013 The template type of the component, such as \"VAV\" for Variable Air Volume boxes.</li> <li><code>path_keyword</code> (str, optional) \u2013 A keyword to search for within the component\u2019s path. If filtering by template type alone, this must be set to an empty string (\"\"), otherwise, a 500 error will occur.</li> <li><code>only_subscribed</code> (bool, default False) \u2013 If True, filters only components that are subscribed.</li> </ul>"},{"location":"reference/#usage-examples","title":"Usage Examples","text":"<p>Retrieving VAV Components by Path Keyword To retrieve all VAV components assigned to a building, filtering by a specific keyword in the path:</p> <p><pre><code>filter = ComponentFilter()\nfilter.template_type = \"VAV\"\nfilter.path_keyword = \"AHU_1_VAVs\"\n\nprint(b.components.by_building(4294967304, filter))\n</code></pre> This retrieves all VAV components associated with the building ID 4294967304 that contain \"AHU_1_VAVs\" anywhere in their path.</p>"},{"location":"reference/#filtering-by-template-type-alone","title":"Filtering by Template Type Alone","text":"<p>If filtering by template type only, the path_keyword must be set to an empty string:</p> <pre><code>filter = ComponentFilter()\nfilter.template_type = \"VAV\"\nfilter.path_keyword = \"\"  # Must be explicitly set to avoid error\n\nprint(b.components.by_building(4294967304, filter))\n</code></pre>"},{"location":"reference/#retrieving-only-subscribed-components","title":"Retrieving Only Subscribed Components","text":"<p>To fetch only subscribed components, set only_subscribed to True:</p> <pre><code>filter = ComponentFilter()\nfilter.template_type = \"VAV\"\nfilter.path_keyword = \"AHU_1_VAVs\"\nfilter.only_subscribed = True\n\nprint(b.components.by_building(4294967304, filter))\nThis will return only components that meet the filtering criteria and are subscribed.\nSearching All Buildings for a Filter\nTo can search the entire BDX site for components with a certain name by looping through all buildings and applying filters to the components assigned to each building.\nimport pandas as pd\nfrom bdx.core import BDX\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.components import ComponentFilter\n\n# Authenticate and initialize BDX\nauth = UsernameAndPasswordAuthenticator(\"your_username\", \"your_password\")\nbdx_instance = BDX(\"https://your-bdx-instance.com\", auth)\n\n# Get a list of all buildings\nbuilding_summaries = bdx_instance.buildings.list()\n\n# Create a filter to search for components\nfilter = ComponentFilter()\nfilter.template_type = \"VAV\"\nfilter.path_keyword = \"AHU_1_VAVs\"  # Adjust search term\n\n# Store results in a list\nall_components = []\n\nfor building in building_summaries:\n    building_id = building.componentInstanceId\n    print(f\"Searching in building: {building.name} (ID: {building_id})\")\n\n    # Retrieve components matching the filter in this building\n    components = bdx_instance.components.by_building(building_id, filter)\n\n    # Add retrieved components to the list\n    for comp in components:\n        all_components.append({\n            \"Building Name\": building.name,\n            \"Building ID\": building_id,\n            \"Component ID\": comp.componentInstanceId,\n            \"Component Path ID\": comp.path.componentPathId if comp.path else None,\n            \"Template Type\": comp.templateType,\n            \"Path\": comp.path.fullPath if comp.path else None,\n            \"Display Name\": comp.path.displayName if comp.path else None,\n            \"Data Collection ID\": comp.path.clientDataCollectionId if comp.path else None\n        })\n\n# Convert to DataFrame\ndf = pd.DataFrame(all_components)\n\n# Display the results\nprint(df)\n\n# Save to CSV for analysis (optional)\ndf.to_csv(\"filtered_components_across_buildings.csv\", index=False)\n</code></pre>"},{"location":"reference/#data-retrieval","title":"Data Retrieval","text":"<p>Now that you have components, you can select properties of components and retrieve data. The Trending module and function in BDXpy allows you to retrieve time series data for various properties of components. Once the timeseries data is in a data frame in python various filters, transformations, analysis, etc. can be applied. There are several methods in which to call data. Data can be called right from a Trendview ID or by <code>componentPathId</code>. After retrieving data the names/column labels a user might desire modifications as BDXpy returns the <code>componentPathId</code> in the column header. This can be revised to a custom-user defined label or if calling view Trendview ID inherit the trend labels.</p>"},{"location":"reference/#methods-for-data-retrieval","title":"Methods for Data Retrieval","text":""},{"location":"reference/#method-1-retrieve-data-using-component-pathproperty-combinations","title":"Method 1 - retrieve data using component path/property combinations","text":"<p><pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame\n\ndef main():\nwith BDX(\"http://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n\n# 21474864282 is an example ID of an AHU. Below calls that AHU and some properties\n        r = bdx_instance.trending.retrieve_data([\n            {\n                \"propertyName\": \"coolOutput\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"ductStaticPressure\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"ductStaticPressureSetpoint\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"heatOutput\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"mixedAirTemp\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"outdoorAirDamperPos\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"outdoorAirTemp\",\n                \"componentPathId\": 21474864282,\n            }])\n\n # Output the first few rows and variables of data        \n        print(r.dataframe)\n\n# Information about the columns can also be printed to help see things like \u2018deviceType\u2019 or \u2018displayName\u2019        \n\n        print(r.column_information)\nmain()\n</code></pre> Outputs: <pre><code>time  21474864282_coolOutput  ...  21474864282_outdoorAirDamperPos  21474864282_outdoorAirTemp\n0   2024-12-27 00:00:00-05:00                     0.0  ...                              0.0                   42.300949\n1   2024-12-27 00:15:00-05:00                     0.0  ...                              0.0                   42.148983\n2   2024-12-27 00:30:00-05:00                     0.0  ...                              0.0                   42.351444\n3   2024-12-27 00:45:00-05:00                     0.0  ...                              0.0                   42.401859\n4   2024-12-27 01:00:00-05:00                     0.0  ...                              0.0                   42.602707\n\n[716 rows x 8 columns]\n{'21474864282_coolOutput': {'propertyName': 'coolOutput', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_ductStaticPressure': {'propertyName': 'ductStaticPressure', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_ductStaticPressureSetpoint': {'propertyName': 'ductStaticPressureSetpoint', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_heatOutput': {'propertyName': 'heatOutput', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_mixedAirTemp': {'propertyName': 'mixedAirTemp', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_outdoorAirDamperPos': {'propertyName': 'outdoorAirDamperPos', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}, '21474864282_outdoorAirTemp': {'propertyName': 'outdoorAirTemp', 'componentPathId': 21474864282, 'virtualPath': None, 'lineStyle': 'normal', 'dataTableOnly': False, 'glyphStyle': 'Circle', 'deviceInfo': {'deviceDto': {'id': 470987, 'deviceType': 'ErwDrawThrough', 'nativeDeviceId': 21474836486}, 'displayName': 'AHU1'}}}\n</code></pre></p>"},{"location":"reference/#method-2-retrieve-a-pre-defined-trend-then-get-its-data","title":"Method 2 - retrieve a pre-defined trend, then get its data","text":"<p><pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame\n\ndef main():\nwith BDX(\"http://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n\n# 635 is the trend ID which can be found in trendview\n\n        t = bdx_instance.trending.trends(635)\n        d = t.retrieve_data(TimeFrame.last_7_days())\n\n        print(d.dataframe)\n\n\nmain()\n</code></pre> Outputs: <pre><code>time  73014470773_realPowerDemand  73014470744_realPowerDemand  fbaaca38439e857f939d395d7948c5510c8d05f7_totalDemand\n0   2024-12-30 11:30:00-05:00                  1180.125122                   944.100098                                        2124.225220\n1   2024-12-30 11:45:00-05:00                  1314.464478                  3286.161133                                        4600.625610\n2   2024-12-30 12:00:00-05:00                  1321.848755                  3304.621826                                        4626.470581\n3   2024-12-30 12:15:00-05:00                  1330.281860                  3325.704590                                        4655.986450\n4   2024-12-30 12:30:00-05:00                  1434.879639                  3874.174805                                        5309.054443\n</code></pre></p>"},{"location":"reference/#finding-trendview-id","title":"Finding Trendview ID","text":"<p>A list of all saved trends can be called in BDXpy. A hyperlink of a saved trend can be referenced like in the image below. </p> <p>Pasted hyperlink with highlighted trend ID 635: <code>http://yourBDXURL.com/trendview/index.html?open=635&amp;timeframe=last7Days&amp;aggregationLevel=Point</code></p>"},{"location":"reference/#names-and-labels","title":"Names and Labels","text":"<p>Now that you have data lets rename the labels by replacing the <code>componentPathId</code> in the column headers with the TrendView label or the equipment display name.</p>"},{"location":"reference/#renaming-labels-in-bdxpy","title":"Renaming Labels in BDXpy","text":""},{"location":"reference/#example-1-displayname-and-property-as-column-labels","title":"Example 1: displayName and Property as column labels","text":"<pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame\n\ndef main():\nwith BDX(\"http://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n\n# 21474864282 is an example ID of an AHU. Below calls that AHU and some properties\n        r = bdx_instance.trending.retrieve_data([\n            {\n                \"propertyName\": \"coolOutput\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"ductStaticPressure\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"ductStaticPressureSetpoint\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"heatOutput\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"mixedAirTemp\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"outdoorAirDamperPos\",\n                \"componentPathId\": 21474864282,\n            },\n            {\n                \"propertyName\": \"outdoorAirTemp\",\n                \"componentPathId\": 21474864282,\n            }])\n\n# Extract the dataframe from the response\n    df = r.dataframe  # Now 'df' holds the DataFrame with your data\n\n    # 'r.column_information' contains the metadata for the columns\n    column_information = r.column_information\n\n    new_column_names = {}  # Create an empty dictionary to store the new column names.\n\n    # Loop through each column and its associated metadata in the column_information dictionary.\n    for col, info in column_information.items():\n        # Try to get the 'label' from the metadata. If no label is provided, it will return None.\n        label = info.get('label', None)\n\n        if label:\n            # If a 'label' exists, use it as the new column name.\n            new_column_names[col] = label\n        else:\n            # If no 'label' is available, we fall back to constructing a column name\n            # based on the device's display name and the property name.\n            device_name = info['deviceInfo']['displayName']\n            property_name = info['propertyName']\n            new_column_names[col] = f\"{device_name}_{property_name}\"\n\n    # Apply the new column names to the DataFrame.\n    df.rename(columns=new_column_names, inplace=True)\n    print(df.head())\n\nmain()\n</code></pre> <p>Notice how in the outputs the <code>componentPathId</code> is replaced with the <code>displayName</code> of the device and columns are labeled <code>AHU1_ductStaticPressure</code> instead of <code>21474864282 ductStaticPressure</code></p> <p>Output: <pre><code>time  AHU1_coolOutput  AHU1_ductStaticPressure  ...  AHU1_mixedAirTemp  AHU1_outdoorAirDamperPos  AHU1_outdoorAirTemp\n0 2024-12-27 00:00:00-05:00              0.0                 -0.02514  ...          66.657455                       0.0            42.300949\n1 2024-12-27 00:15:00-05:00              0.0                 -0.02514  ...          66.688950                       0.0            42.148983\n2 2024-12-27 00:30:00-05:00              0.0                 -0.02514  ...          66.688950                       0.0            42.351444\n3 2024-12-27 00:45:00-05:00              0.0                 -0.02514  ...          66.657455                       0.0            42.401859\n4 2024-12-27 01:00:00-05:00              0.0                 -0.02514  ...          66.625923                       0.0            42.602707\n</code></pre></p>"},{"location":"reference/#example-2-modifying-labels-from-a-trendview-id-function","title":"Example 2: Modifying Labels from a Trendview ID function","text":"<pre><code>import pandas as pd\nfrom bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame\n\n# Function to call the BDX API and retrieve data\ndef api_call(trend_id, timeframe):\n    try:\n        with BDX(\"http://yourBDXURL.com\", UsernameAndPasswordAuthenticator(\"BDX_USERNAME\", \"BDX_PASSWORD\")) as bdx_instance:\n            trend = bdx_instance.trending.trends(trend_id)\n            data = trend.retrieve_data(timeframe)\n            df = data.dataframe\n\n            # Use true column names from displayName if available\n            true_column_names = [value['deviceInfo']['displayName'] if 'deviceInfo' in value and 'displayName' in value['deviceInfo'] else key \n                                 for key, value in data.column_information.items()]\n            df.columns = ['time'] + true_column_names[:len(df.columns) - 1] \n            return df\n\n    except Exception as e:\n        print(f\"Error fetching data from API: {e}\")\n        return None\n\ndef main():\n    try:\n        trend_ids = 597\n        timeframe = TimeFrame.last_n_days(4)\n        df = api_call(trend_ids, timeframe)\n\n        if df is None:\n            print(\"No data returned from API.\")\n            return\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nmain ()\n</code></pre> <p>Output: <pre><code>time  N_Street_Elec  N_Hill_Elec  BuildingLogiX Campus\n0   2024-12-30 11:30:00-05:00    1180.125122   944.100098           2124.225220\n1   2024-12-30 11:45:00-05:00    1314.464478  3286.161133           4600.625610\n2   2024-12-30 12:00:00-05:00    1321.848755  3304.621826           4626.470581\n3   2024-12-30 12:15:00-05:00    1330.281860  3325.704590           4655.986450\n</code></pre></p>"},{"location":"reference/#replace-labels-manually-in-python","title":"Replace Labels Manually in Python","text":"<p>If you manually want to create a list to rename a data frame columns by matching on IDs, something like these functions can be added to your code:</p> <pre><code>def get_custom_display_names(data_response, custom_display_names):\n    \"\"\"\n    Renames DataFrame columns based on custom display names and 'propertyName' from component metadata.\n\n    Parameters:\n    data_response: The response object containing both the DataFrame and column metadata.\n    custom_display_names (dict): A dictionary mapping componentPathId to custom display names.\n\n    Returns:\n    DataFrame: DataFrame with columns renamed as 'CustomDisplayName_propertyName'.\n    \"\"\"\n    # Retrieve the DataFrame and column information\n    df = data_response.dataframe\n    column_information = data_response.column_information\n\n    new_column_names = {}\n\n    # Loop through each column and its metadata\n    for col, info in column_information.items():\n        component_path_id = info.get('componentPathId')\n\n        # Use custom display name if available; otherwise, fall back to displayName\n        display_name = custom_display_names.get(component_path_id, info.get('deviceInfo', {}).get('displayName', 'Unknown'))\n\n        # Ensure 'propertyName' exists\n        property_name = info.get('propertyName', 'UnknownProperty')\n\n        # Construct new column name as 'CustomDisplayName_propertyName'\n        new_column_names[col] = f\"{display_name}_{property_name}\"\n\n    # Rename DataFrame columns\n    df.rename(columns=new_column_names, inplace=True)\n\n    return df\n\ndf_compressors = get_custom_display_names(data_response, custom_display_names)\n</code></pre>"},{"location":"reference/#timeframes-and-aggregations","title":"Timeframes and Aggregations","text":"<p>BDXpy allows users to retrieve trend data for specific timeframes and aggregate the data based on desired intervals. This provides flexibility for analyzing trends over varying periods and resolutions.</p>"},{"location":"reference/#timeframes","title":"Timeframes","text":"<p>Timeframes define the duration of the data to retrieve. BDXpy provides several predefined options, such as:</p> <ul> <li><code>TimeFrame.last_7_days()</code> for data from the past seven days.</li> <li><code>TimeFrame.last_30_days()</code> for data from the past 30 days.</li> <li><code>TimeFrame.last_n_days()</code> for specifying a discrete number of days.</li> </ul> <p>Users can also define custom timeframes by specifying a start and end datetime that is covered in the examples below.</p>"},{"location":"reference/#aggregations","title":"Aggregations","text":"<p>Aggregations control how data is grouped or summarized over time. The default mode is point-level samples and doesn\u2019t need called in the retrieval function. Aggregation options include for example:  </p> <ul> <li><code>AggregationLevel.POINT</code></li> <li><code>AggregationLevel.HOURLY</code></li> <li><code>AggregationLevel.DAILY</code></li> <li><code>AggregationLevel.WEEKLY</code></li> <li><code>AggregationLevel.MONTHLY</code></li> <li><code>AggregationLevel.YEARLY</code></li> </ul> <p>Combining timeframes and aggregation levels allows users to tailor their trend data queries to their specific needs.</p>"},{"location":"reference/#example-retrieve-trend-data-with-timeframes-and-aggregations","title":"Example: Retrieve Trend Data with Timeframes and Aggregations","text":"<pre><code>from bdx.auth import UsernameAndPasswordAuthenticator\nfrom bdx.core import BDX\nfrom bdx.types import TimeFrame, AggregationLevel\n\n# Replace with your credentials and BDX URL\nBDX_URL = \"http://your-bdx-url.com\"\nUSERNAME = \"your_username\"\nPASSWORD = \"your_password\"\n\nauthenticator = UsernameAndPasswordAuthenticator(USERNAME, PASSWORD)\n\nwith BDX(BDX_URL, authenticator) as bdx_instance:\n    # Retrieve a specific trend\n    trend = bdx_instance.trending.trends(635)\n\n    # Retrieve data for the last 7 days with daily aggregation\n    trend_data1 = trend.retrieve_data(\n        timeframe=TimeFrame.last_7_days(),\n        aggregation=AggregationLevel.DAILY\n    )\n    # Retrieve data for the last 60 days with hourly aggregation\n    trend_data2 = trend.retrieve_data(\n        timeframe=TimeFrame.last_n_days(60),\n        aggregation=AggregationLevel.HOURLY\n    )\n</code></pre>"},{"location":"reference/#python-exception-errors","title":"Python Exception Errors","text":"<p>The package includes custom exceptions for handling errors that might occur when running a python script with BDXpy:  </p> <ul> <li><code>AuthenticationError</code> \u2192 When calling BDXSession() or BDX() and login credentials fail.</li> <li><code>HttpRequestError</code> \u2192 When retrieving trends, buildings, or components from the BDX API.</li> <li><code>DataNotFoundError</code> \u2192 When requesting a component, trend, or time series that doesn\u2019t exist.</li> <li><code>SecurityError</code> \u2192 When trying to access a restricted resource (e.g., a building component you don\u2019t have access to).</li> </ul>"},{"location":"reference/#bdxpy-modules-user-facing-only","title":"BDXpy Modules (User-Facing Only)","text":"<ol> <li><code>auth.py</code> \u2013 Manages authentication, including username/password login.</li> <li><code>buildings.py</code> \u2013 Allows users to retrieve building data, including addresses, zones, and assigned components.</li> <li><code>components.py</code> \u2013 Enables component lookups, including retrieving information about HVAC systems, meters, sensors, and other building components.</li> <li><code>core.py</code> \u2013 Provides the main interface for interacting with BDX, wrapping session management and data retrieval.</li> <li><code>trending.py</code> \u2013 Handles trend data retrieval, allowing users to query, filter, and analyze time-series data from BDX.</li> <li><code>types.py</code> \u2013 Defines helper classes, enumerations, and error handling for API interactions.</li> </ol>"},{"location":"examples/comingsoon/","title":"COMING SOON....","text":""},{"location":"examples/Basic%20Charting%20and%20Data%20Visualization/example1/","title":"Example 1: placholder","text":"<p>This example demonstrates how to use BDXPy to analyze building data.</p>"},{"location":"examples/Basic%20Charting%20and%20Data%20Visualization/example1/#output","title":"Output","text":"Show Code <pre><code>from bdxpy import DataLoader\n\ndata = DataLoader.load(\"building_data.csv\")\nprint(data.summary())\n</code></pre>"},{"location":"examples/Basic%20Charting%20and%20Data%20Visualization/example2/","title":"Example 2: Advanced Analysis","text":"Show Code <p>Perform advanced analysis with weather-adjusted modeling. <pre><code>from bdxpy import WeatherModel\n\nmodel = WeatherModel()\nmodel.fit(data)\nprint(model.results())\n</code></pre></p>"},{"location":"examples/Dashboards/rtu_dash_ex/","title":"RTU Monitor","text":""},{"location":"examples/Dashboards/rtu_dash_ex/#example-rtu-monitoring","title":"Example: RTU Monitoring","text":"<p>Dash app containing standard colors and timeframes for various means of display on RTU data from BDX</p> \ud83d\udd0d Click for Fullscreen <p>This example demonstrates a dashboard for monitoring RTU (Rooftop Unit) performance using BDXpy. It features:</p> <ul> <li>Real-time Data Visualization: Tracks key RTU metrics over time.</li> <li>Interactive Graphs &amp; Charts: Provides insights into energy consumption and efficiency.</li> <li>Responsive Web Design: Accessible on both desktop and mobile.</li> </ul> <p>To explore the dashboard, visit the live demo above or check out the source code.</p>"}]}